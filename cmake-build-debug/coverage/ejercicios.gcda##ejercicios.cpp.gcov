        -:    0:Source:C:/Users/berin/Documents/facultad/exactas/1ero/ALGO 1/tpi2/ejercicios.cpp
        -:    0:Graph:C:\Users\berin\Documents\facultad\exactas\1ero\ALGO 1\tpi2\cmake-build-debug\CMakeFiles\tpi2.dir\ejercicios.gcno
        -:    0:Data:C:\Users\berin\Documents\facultad\exactas\1ero\ALGO 1\tpi2\cmake-build-debug\CMakeFiles\tpi2.dir\ejercicios.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Este archivo contiene las definiciones de las funciones que implementan los ejercicios
        -:    3://
        -:    4:
        -:    5:#include <stdio.h>
        -:    6:#include <iostream>
        -:    7:
        -:    8:
        -:    9:#include "definiciones.h"
        -:   10:#include "ejercicios.h"
        -:   11:#include "auxiliares.h"
        -:   12:
        -:   13:using namespace std;
        -:   14:
        -:   15:/******++++**************************** EJERCICIO minasAdyacentes ***********+++***********************/
        -:   16:
        -:   17:/*
        -:   18: Sea cual sea la posicion y el tamano del tablero, pasa 3 veces por el primer loop for y 3 veces en el segundo loop for  por cada una de las 3 del primero, // o sea que entra 9 veces al segundo loop for.
        -:   19: Es decir, al pasarle una posicion itera la misma cantidad de veces sin importar el tamaño del tablero de entrada.
        -:   20: Por lo tanto la complejidad temporal es de orden O(1).
        -:   21: */
        -:   22:
function _Z15minasAdyacentesRSt6vectorIS_IbSaIbEESaIS1_EESt4pairIiiE called 83 returned 100% blocks executed 90%
       83:   23:int minasAdyacentes(tablero& t, pos p) {
        -:   24:
       83:   25:    int minas = 0;
       83:   26:    int p0 = p.first;
       83:   27:    int p1 = p.second;
        -:   28:
      332:   29:    for(int fila = -1; fila<=1; fila++){
       83:   29-block  0
      249:   29-block  1
      332:   29-block  2
branch  0 taken 249
branch  1 taken 83 (fallthrough)
      996:   30:        for(int col = -1; col <=1; col++){
      249:   30-block  0
      747:   30-block  1
      996:   30-block  2
branch  0 taken 747
branch  1 taken 249 (fallthrough)
        -:   31:
      747:   32:            if (adyacenteValida(t,p, fila, col) && t[p0+fila][p1+col] == cMINA){
      747:   32-block  0
call    0 returned 747
branch  1 taken 747 (fallthrough)
branch  2 taken 0 (throw)
      747:   32-block  1
branch  3 taken 588 (fallthrough)
branch  4 taken 159
      588:   32-block  2
call    5 returned 588
call    6 returned 588
branch  7 taken 588 (fallthrough)
branch  8 taken 0 (throw)
      588:   32-block  3
call    9 returned 588
branch 10 taken 92 (fallthrough)
branch 11 taken 496
       92:   32-block  4
      655:   32-block  5
      747:   32-block  6
branch 12 taken 92 (fallthrough)
branch 13 taken 655
    $$$$$:   32-block  7
       92:   33:                minas++;
       92:   33-block  0
        -:   34:            }
        -:   35:        }
        -:   36:    }
       83:   37:    return minas;
       83:   37-block  0
       83:   37-block  1
        -:   38:}
        -:   39:
        -:   40:/******++++**************************** EJERCICIO cambiarBanderita ***********+++***********************/
        -:   41:
        -:   42:/*
        -:   43: En esta funcion tenemos un loop for que recorre toda la lista de banderitas, y en el peor de los casos se le pasa a la funcion la ultima posicion del tablero,
        -:   44: y dentro de la lista de banderitas estan todas las posiciones del tablero.
        -:   45: Analogamente, con la funcion posicionJugada,que esta dentro de la funcion principal, ocurre lo mismo pero como no estan anidadas no aumento la complejidad.
        -:   46: Teniendo en cuenta esto, podemos decir que la complejidad temporal es de orden O(t.size()) o seria lo mismo decir O(n).
        -:   47:
        -:   48:*/
function _Z16cambiarBanderitaRSt6vectorIS_IbSaIbEESaIS1_EERS_ISt4pairIS5_IiiEiESaIS7_EES6_RS_IS6_SaIS6_EE called 3 returned 100% blocks executed 89%
        3:   49:void cambiarBanderita(tablero& t, jugadas& j, pos p, banderitas& b) {
        -:   50:
        6:   51:    for (int i = 0; i < b.size(); i++){
        3:   51-block  0
        3:   51-block  1
        6:   51-block  2
call    0 returned 6
branch  1 taken 4
branch  2 taken 2 (fallthrough)
        4:   52:        if (b[i] == p){
        4:   52-block  0
call    0 returned 4
call    1 returned 4
branch  2 taken 1 (fallthrough)
branch  3 taken 3
        1:   53:            b.erase(b.begin()+i);
        1:   53-block  0
call    0 returned 1
call    1 returned 1
call    2 returned 1
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
    $$$$$:   53-block  1
    $$$$$:   53-block  2
        1:   54:            return;
        1:   54-block  0
        -:   55:        }
        -:   56:    }
        2:   57:    bool posJugada = posicionJugada(j,p);
        2:   57-block  0
call    0 returned 2
        2:   58:    if (not(posJugada)){
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   59:        b.push_back(p);
        1:   59-block  0
call    0 returned 1
        -:   60:    }
        -:   61:}
        -:   62:
        -:   63:/******++++**************************** EJERCICIO perdio ***********+++***********************/
        -:   64:
        -:   65:/*
        -:   66: En este ejercicio tenemos una funcion depende temporalmente de lista de jugadas que en el peor de los casos contiene al tablero entero
        -:   67: Por lo tanto la complejidad temporal es de orden O(j.size()), que seria lo mismo a decir O(n).
        -:   68: */
        -:   69:
function _Z6perdioRSt6vectorIS_IbSaIbEESaIS1_EERS_ISt4pairIS5_IiiEiESaIS7_EE called 3 returned 100% blocks executed 93%
        3:   70:bool perdio(tablero& t, jugadas& j) {
        -:   71:
        3:   72:    bool res = false;
       11:   73:    for (int i = 0; i < j.size(); i++){
        3:   73-block  0
        8:   73-block  1
       11:   73-block  2
call    0 returned 11
branch  1 taken 8
branch  2 taken 3 (fallthrough)
        -:   74:
        8:   75:        pair<int,int> p = j[i].first;
        8:   75-block  0
call    0 returned 8
        8:   76:        int p0 = p.first;
        8:   77:        int p1 = p.second;
        -:   78:
        8:   79:        if (t[p0][p1] == cMINA){
call    0 returned 8
call    1 returned 8
branch  2 taken 8 (fallthrough)
branch  3 taken 0 (throw)
        8:   79-block  0
call    4 returned 8
branch  5 taken 1 (fallthrough)
branch  6 taken 7
    $$$$$:   79-block  1
        1:   80:            res = true;
        1:   80-block  0
        -:   81:        }
        -:   82:    }
        3:   83:    return res;
        3:   83-block  0
        3:   83-block  1
        -:   84:}
        -:   85:
        -:   86:/******++++**************************** EJERCICIO gano ***********+++***********************/
        -:   87:
        -:   88:/*
        -:   89: En este ejercicio tenemos una funcion dentro de la principal llamada CasillasVacias(t) que recorre el tablero  entero y devuelve un vector de posiciones, con aquellas que estan vacias.
        -:   90: En el peor de los casos, el tablero esta lleno de casillas vacias y fueron todas jugadas.
        -:   91: Se itera sobre la cantidad de posiciones vacias y luego dentro de la funcion posicionJugada(j,p).
        -:   92: Por lo tanto la complejidad temporal resutante es de orden O(n²).
        -:   93:*/
        -:   94:
        -:   95:
function _Z4ganoRSt6vectorIS_IbSaIbEESaIS1_EERS_ISt4pairIS5_IiiEiESaIS7_EE called 3 returned 100% blocks executed 84%
        3:   96:bool gano(tablero& t, jugadas& j) {
        -:   97:
        3:   98:    vector<pos> posicionesDeCasillasVacias = CasillasVacias(t);
        3:   98-block  0
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:   99:
        3:  100:    int contador = 0;
        -:  101:
       60:  102:    for (int i = 0; i < posicionesDeCasillasVacias.size(); i++){
        3:  102-block  0
       57:  102-block  1
       60:  102-block  2
call    0 returned 60
branch  1 taken 57
branch  2 taken 3 (fallthrough)
       57:  103:        pos p = posicionesDeCasillasVacias[i];
       57:  103-block  0
call    0 returned 57
       57:  104:        if (posicionValida(t,p)){
call    0 returned 57
branch  1 taken 57 (fallthrough)
branch  2 taken 0 (throw)
       57:  104-block  0
branch  3 taken 57 (fallthrough)
branch  4 taken 0
       57:  105:            if (posicionJugada(j,p)){
       57:  105-block  0
call    0 returned 57
branch  1 taken 57 (fallthrough)
branch  2 taken 0 (throw)
       57:  105-block  1
branch  3 taken 31 (fallthrough)
branch  4 taken 26
       31:  106:                contador++;
       31:  106-block  0
        -:  107:            }
        -:  108:        }
        -:  109:    }
        3:  110:    bool res = (contador == posicionesDeCasillasVacias.size());
        3:  110-block  0
call    0 returned 3
        3:  111:    return res;
        3:  111-block  0
        3:  112:}
call    0 returned 3
    $$$$$:  112-block  0
call    1 never executed
        -:  113:
        -:  114:/******++++**************************** EJERCICIO jugarPlus ***********+++***********************/
        -:  115:
        -:  116:/*
        -:  117: Esta funcion se fija que la posicion que se le pasa como parametro no este jugada ni tenga una banderita, se le calcula la cantidad de minas adyacentes y se la agrega a la lista de jugadas.
        -:  118: Luego se fija que sea una posicion vacia y que no tenga minas adyacentes, y si esto es asi, recorre por medio de dos loop for para descubrir todas esas posiciones.
        -:  119: Y asi con todas esas posiciones descubiertas se hace lo mismo llamando otra vez a la funcion, que es entonces recursiva.
        -:  120: En el peor de los casos, el tablero esta completamente lleno de casillas vacias y todas fueron jugadas.
        -:  121: Al ser una funcion recursiva no se puede calcular la complejidad temporal, pero sabemos que en el peor de los casos se itera sobre todas las posiciones del tablero.
        -:  122: Podemos decir que las condiciones pedidas en la funcion aseguran la terminacion de la misma.
        -:  123:
        -:  124:*/
        -:  125:
        -:  126:
function _Z9jugarPlusRSt6vectorIS_IbSaIbEESaIS1_EERS_ISt4pairIiiESaIS6_EES6_RS_IS5_IS6_iESaISA_EE called 10 returned 100% blocks executed 79%
       10:  127:void jugarPlus(tablero& t, banderitas& b, pos p, jugadas& j) {
        -:  128:
       10:  129:    bool posJugada = posicionJugada(j,p);
       10:  129-block  0
call    0 returned 10
       10:  130:    bool posBanderita = posicionTieneBanderita(b,p);
call    0 returned 10
        -:  131:
       10:  132:    if (not posJugada && not posBanderita){
branch  0 taken 7 (fallthrough)
branch  1 taken 3
        7:  132-block  0
branch  2 taken 6 (fallthrough)
branch  3 taken 1
        -:  133:
        6:  134:        int cantidadMinasAdyacentes = minasAdyacentes(t,p);
        6:  134-block  0
call    0 returned 6
branch  1 taken 6 (fallthrough)
branch  2 taken 0 (throw)
        6:  135:        j.push_back(make_pair(p, cantidadMinasAdyacentes));
        6:  135-block  0
call    0 returned 6
branch  1 taken 6 (fallthrough)
branch  2 taken 0 (throw)
        6:  135-block  1
call    3 returned 6
branch  4 taken 6 (fallthrough)
branch  5 taken 0 (throw)
    $$$$$:  135-block  2
        -:  136:
        6:  137:        if (t[p.first][p.second] == cVACIA){
        6:  137-block  0
call    0 returned 6
call    1 returned 6
branch  2 taken 6 (fallthrough)
branch  3 taken 0 (throw)
        6:  137-block  1
call    4 returned 6
branch  5 taken 5 (fallthrough)
branch  6 taken 1
    $$$$$:  137-block  2
        5:  138:            if (cantidadMinasAdyacentes == 0){
        5:  138-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        4:  139:                for(int fila = -1; fila<=1; fila++){
        1:  139-block  0
        3:  139-block  1
        4:  139-block  2
branch  0 taken 3
branch  1 taken 1 (fallthrough)
       12:  140:                    for(int col = -1; col <=1; col++){
        3:  140-block  0
        9:  140-block  1
       12:  140-block  2
branch  0 taken 9
branch  1 taken 3 (fallthrough)
        9:  141:                        if (adyacenteValida(t,p, fila, col)){
        9:  141-block  0
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0 (throw)
        9:  141-block  1
branch  3 taken 5 (fallthrough)
branch  4 taken 4
        5:  142:                            pos q = make_pair(p.first+fila, p.second+col);
        5:  142-block  0
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
    $$$$$:  142-block  1
    $$$$$:  142-block  2
        5:  143:                            jugarPlus(t, b, q, j);
        5:  143-block  0
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
        -:  144:                        }
        -:  145:                    }
        -:  146:                }
        -:  147:            }
        -:  148:        }
        -:  149:    }
       10:  150:}
       10:  150-block  0
        -:  151:
        -:  152:/******++++**************************** EJERCICIO sugerirAutomatico121 ***********+++***********************/
        -:  153:
        -:  154:/*
        -:  155: De lo que se encarga la funcion es de buscar una posicion que cumpla con la especificacion pedida.
        -:  156: Recorre el tablero, y si encuentra una posicion que cumpla que este sin jugar ni tenga banderita y sea adyacente a un patron 121, la envia a lista de jugadas, y luego devuelve la posicion y true.
        -:  157: En el peor de los casos, el patron 121 se encuentra muy carca del borde inferior derecho del tablero y se tienen que probar practicamente todas las posiciones del tablero para encontrar la posicion.
        -:  158: Por un lado dos primero dos for anidados que recorren el tablero tienen una complejidad de O(n²).
        -:  159: Luego, esPosicionSinJugarYSinBanderita tiene una complejidad de O(n²) y esAdyacente121 de O(n^12).
        -:  160: Por lo tanto la complejidad temporal de la funcion total es de orden O(n^16).
        -:  161:
        -:  162:*/
        -:  163:
function _Z20sugerirAutomatico121RSt6vectorIS_IbSaIbEESaIS1_EERS_ISt4pairIiiESaIS6_EERS_IS5_IS6_iESaISA_EERS6_ called 5 returned 100% blocks executed 85%
        5:  164:bool sugerirAutomatico121(tablero& t, banderitas& b, jugadas& j, pos& p) {
        -:  165:
        5:  166:    bool hay = false;
       22:  167:    for (int i = 0; i < t.size(); i++){
        5:  167-block  0
       17:  167-block  1
       22:  167-block  2
call    0 returned 22
branch  1 taken 19
branch  2 taken 3 (fallthrough)
      106:  168:        for (int k = 0; k < t[0].size(); k++){
       19:  168-block  0
       87:  168-block  1
      106:  168-block  2
call    0 returned 106
call    1 returned 106
branch  2 taken 89
branch  3 taken 17 (fallthrough)
        -:  169:
       89:  170:            pos q = make_pair(i,k);
       89:  170-block  0
call    0 returned 89
branch  1 taken 89 (fallthrough)
branch  2 taken 0 (throw)
       89:  171:            if (esPosicionSinJugarYSinBanderita(t,j,b,q) && esAdyacente121(q, j, t)){
       89:  171-block  0
call    0 returned 89
branch  1 taken 89 (fallthrough)
branch  2 taken 0 (throw)
       89:  171-block  1
branch  3 taken 58 (fallthrough)
branch  4 taken 31
       58:  171-block  2
call    5 returned 58
branch  6 taken 58 (fallthrough)
branch  7 taken 0 (throw)
       58:  171-block  3
branch  8 taken 2 (fallthrough)
branch  9 taken 56
        2:  171-block  4
       87:  171-block  5
       89:  171-block  6
branch 10 taken 2 (fallthrough)
branch 11 taken 87
        2:  172:                if (t[i][k] == cVACIA) {
        2:  172-block  0
call    0 returned 2
call    1 returned 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0 (throw)
        2:  172-block  1
call    4 returned 2
branch  5 taken 2 (fallthrough)
branch  6 taken 0
    $$$$$:  172-block  2
        2:  173:                    p = q;
        2:  173-block  0
call    0 returned 2
        2:  174:                    j.push_back(make_pair(p, minasAdyacentes(t, p)));
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  174-block  0
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0 (throw)
        2:  174-block  1
call    6 returned 2
branch  7 taken 2 (fallthrough)
branch  8 taken 0 (throw)
    $$$$$:  174-block  2
    $$$$$:  174-block  3
        2:  175:                    hay = true;
        2:  176:                    return hay;
        2:  176-block  0
        -:  177:                }
        -:  178:            }
        -:  179:        }
        -:  180:    }
        3:  181:    return hay;
        3:  181-block  0
        -:  182:}
